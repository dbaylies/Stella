/*
    COPYRIGHT 2024 DAVID BAYLIES
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Audio.h>

// Automatically generated by Teensy Audio Design Tool. xy coordinates represent object locations
// in design tool GUI, are useful for importing back to GUI
AudioInputI2S            i2s1;              //xy=1248,470
AudioFilterBiquad        biquad1;           //xy=1490,391
AudioAnalyzeFFT1024      myFFT;             //xy=1652,450
AudioConnection          patchCord1(i2s1, 0, biquad1, 0);
AudioConnection          patchCord2(biquad1, myFFT);
AudioControlSGTL5000     sgtl5000;          //xy=1403,624

/////////////////////////////
//// MIDI SEND VARIABLES ////
/////////////////////////////

// previous MIDI note number - initialized to zero
int noteold = 0;

// current MIDI note number
int note;

struct PeakInfo
{
  int mindex; // FFT bin of peak
  float m;    // FFT amplitude of peak
};

/////////////////////////////
///////// CODE SETUP ////////
/////////////////////////////

void setup() 
{
  Serial.begin(250000);
  
  AudioMemory(60);
  
  sgtl5000.enable();
  sgtl5000.inputSelect(AUDIO_INPUT_MIC);
  // Set amplifier gain (in decibels, from 0 to 63)
  sgtl5000.micGain(40);
  // Just sets headphone jack volume
  sgtl5000.volume(0.5);
  
  // Butterworth filter, 12 dB/octave, filters out unnecessary frequencies (trumpet mouthpiece range is 87Hz -> 932 Hz)
  biquad1.setLowpass(0, 1000, 0.707);
  
  // Configure the FFT window algorithm to use
  myFFT.windowFunction(AudioWindowHanning1024);

}

/////////////////////////////
///////// MAIN CODE /////////
/////////////////////////////

void loop() 
{  
  // once new buffer fills, run it through fft
  if (myFFT.available()) 
  {
    // Returns a number (mindex) representing fundamental frequency, as well as that bin's amplitude
    PeakInfo peakInfo = CapturePeak();

    bool peakdetect = peakInfo.mindex != 512;
    sendMIDIdata(peakInfo.mindex, peakInfo.m, peakdetect);
  }
}

/////////////////////////////
/////// VALVE READING ///////
/////////////////////////////
int ReadValves()
{
  // Assign valve variables booleans based on the valve states 
  bool valve1 = analogRead(16) < 512;
  bool valve2 = analogRead(14) < 512;
  bool valve3 = analogRead(17) < 512;

  // Combine all valve states into one number
  return (valve1 << 2) + (valve2 << 1) + valve3;
}

/////////////////////////////
///// FFT PEAK CAPTURE //////
/////////////////////////////
// find and store peak the value and index if it is loud and a lower frequency than the last recorded value.
// This ensures that the fundmental is recorded, and not a harmonic.
// Additionally, don't include very low frequencies because it is likely noise and not the intended pitch
PeakInfo CapturePeak()
{
    // Initialize to a number that is unused. No note will sound if mindex does not change, and remains 512.
    int mindex = 512;
    float m = 0;
    int istart = 0;
    int iend = 0;

    bool endcapture = false;
    bool peakstart = false;

    // Higher i means higher frequencies - I believe there are 26 bins
    for (int i = 0; i < 26; i++)
    {   
      // Include fft correction factor? You should research what the magnitude here represents. What are the units?
      float n = myFFT.read(i); // 1.0 represents a full scale sine wave

      if (n > 0.07 && i > 4 && !peakstart && !endcapture) 
      {
        peakstart = true;
        istart = i;
      }

      if (n < 0.07 && i > 4 && peakstart && !endcapture) 
      {
        endcapture = true;
        iend = i;
        // find number of indexes in the peak
        int peaklength = iend - istart;
        for (int ipk = 0; ipk < peaklength; ipk++) 
        {
          if (myFFT.read(istart + ipk) > m) 
          {
            m = myFFT.read(ipk + istart);
            mindex = ipk + istart;
          }
        }
      }
    }

    return {mindex, m};
}

/////////////////////////////
////////// MIDI SEND ////////
/////////////////////////////

void sendMIDIdata(int mindex, float m, bool peakdetect)
{  
  // Find velocity with the peak FFT value
  // TODO: Change denominator to current max FFT bin amplitude
  // also acts as MIDI volume

  int16_t velocity = m * 127 / 0.6;

  int combo = ReadValves();
  int note = 0;
  // Assign note based on mindex and valve combination
  switch (combo) 
  {
    case 0:
        if (mindex >= 2 && mindex <= 4) {
          note = 40; // E3
        } else if (mindex >= 5 && mindex <= 6) {
          note = 47; // B3
        } else if (mindex >= 7 && mindex <= 8) {
          note = 52; // E4
        } else if (mindex >= 9 && mindex <= 10) {
          note = 56; // Ab4 (G#4)
        } else if (mindex >= 11 && mindex <= 13) {
          note = 59; // B4
        } else if (mindex >= 14 && mindex <= 20) {
          note = 64; // E5
        }
        break;
    case 2:
        if (mindex >= 2 && mindex <= 5) {
          note = 41; // F3
        } else if (mindex >= 6 && mindex <= 7) {
          note = 48; // C4
        } else if (mindex >= 8 && mindex <= 9) {
          note = 53; // F4
        } else if (mindex >= 10 && mindex <= 11) {
          note = 57; // A4
        } else if (mindex >= 12 && mindex <= 14) {
          note = 60; // C5
        } else if (mindex >= 15 && mindex <= 20) {
          note = 65; // F5
        }
        break;
    case 4:
        if (mindex >= 2 && mindex <= 5) {
          note = 42; // Gb3
        } else if (mindex >= 6 && mindex <= 7) {
          note = 49; // Db4
        } else if (mindex >= 8 && mindex <= 9) {
          note = 54; // Gb4
        } else if (mindex >= 10 && mindex <= 11) {
          note = 58; // Bb4
        } else if (mindex >= 12 && mindex <= 14) {
          note = 61; // Db5
        } else if (mindex >= 15 && mindex <= 20) {
          note = 66; // Gb5
        }
        break;
    case 6:
    case 1:
        if (mindex >= 2 && mindex <= 5) {
          note = 43; // G3
        } else if (mindex >= 6 && mindex <= 7) {
          note = 50; // D4
        } else if (mindex >= 8 && mindex <= 10) {
          note = 55; // G4
        } else if (mindex >= 11 && mindex <= 12) {
          note = 59; // B4
        } else if (mindex >= 13 && mindex <= 15) {
          note = 62; // D5
        } else if (mindex >= 16 && mindex <= 22) {
          note = 67; // G5
        }
        break;
    case 3:
        if (mindex >= 2 && mindex <= 5) {
          note = 44; // Ab3
        } else if (mindex >= 6 && mindex <= 8) {
          note = 51; // Eb4
        } else if (mindex >= 9 && mindex <= 10) {
          note = 56; // Ab4
        } else if (mindex >= 11 && mindex <= 13) {
          note = 60; // C5
        } else if (mindex >= 14 && mindex <= 16) {
          note = 63; // Eb5
        } else if (mindex >= 17 && mindex <= 22) {
          note = 68; // Ab5
        }
        break;
    case 5:
        if (mindex >= 2 && mindex <= 6) {
          note = 45; // A3
        } else if (mindex >= 7 && mindex <= 8) {
          note = 52; // E4
        } else if (mindex >= 9 && mindex <= 11) {
          note = 57; // A4
        } else if (mindex >= 12 && mindex <= 13) {
          note = 61; // Db5
        } else if (mindex >= 14 && mindex <= 17) {
          note = 64; // E5
        } else if (mindex >= 18 && mindex <= 22) {
          note = 69; // A5
        }
        break;
    case 7:
        if (mindex >= 2 && mindex <= 6) {
          note = 46; // Bb3
        } else if (mindex >= 7 && mindex <= 9) {
          note = 53; // F4
        } else if (mindex >= 10 && mindex <= 12) {
          note = 58; // Bb4
        } else if (mindex >= 13 && mindex <= 14) {
          note = 62; // D5
        } else if (mindex >= 15 && mindex <= 20) {
          note = 65; // F5
        } else if (mindex >= 21 && mindex <= 22) {
          note = 70; // Bb5
        }
        break; 
  }

  constexpr int channel = 1;

  // Send volume signals whenever a peak is detected
  if (peakdetect == true)
    usbMIDI.sendControlChange(07, velocity, channel);
  
  // Send note on/off data if the note has changed
  if (note != noteold) 
  {
    // Only send note on message if a peak was detected and note !=0
    // TODO: note != 0 part is probably a sloppy way of fixing a bug where playing a note about a high Bb triggers a very low note on (probably note 0)
    if (peakdetect == true && note != 0)
      usbMIDI.sendNoteOn(note, velocity, channel);
    if (noteold != 0)
      usbMIDI.sendNoteOff(noteold, velocity, channel);
  }

  // store note and valve information for next loop's comparisons
  noteold = note;
}
