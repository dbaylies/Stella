/*
    COPYRIGHT 2021 DAVID BAYLIES
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


// Include necessary libraries (TODO: understand and explain individual library functions, remove unnecessary libraries)
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>
// Bounce isn't necessary?
#include <Bounce.h>

// Automatically generated by Teensy Audio Design Tool. xy coordinates represent object locations
// in design tool GUI, are useful for importing back to GUI
AudioInputI2S            i2s1;           //xy=1248,470
AudioRecordQueue         queue1;         //xy=1469,289
AudioOutputI2S           i2s2;           //xy=1483,515
AudioFilterBiquad        biquad1;        //xy=1490,391
AudioAnalyzeFFT1024      myFFT;          //xy=1652,450
AudioConnection          patchCord1(i2s1, 0, i2s2, 0);
AudioConnection          patchCord2(i2s1, 0, i2s2, 1);
AudioConnection          patchCord3(i2s1, 0, biquad1, 0);
AudioConnection          patchCord4(i2s1, 0, queue1, 0);
AudioConnection          patchCord5(biquad1, myFFT);
AudioControlSGTL5000     sgtl5000;     //xy=1403,624


/////////////////////////////
////// VALVE VARIABLES //////
/////////////////////////////

// potentiometer readings
int v1,v2,v3;

// binary valve readings - is it up or down?
bool valve1 = true;
bool valve2 = true;
bool valve3 = true;

// Combined valve comination (three bit number)
int combo;

/////////////////////////////
/////// MISC VARIABLES //////
/////////////////////////////

// Volume found from FFT
float vol;

// float for storing and printing individual fft results
float n;

/////////////////////////////
//// MIDI SEND VARIABLES ////
/////////////////////////////

// storage for audio data, used to find note velocity
int16_t audio[1024];

// Precurser variable to final rms calculation
int64_t tot;

// rms value read in from audio queue
int16_t rms;

// MIDI note velocity
int16_t velocity;

// previous MIDI note number - initialized to zero
int noteold = 0;

// current MIDI note number
int note;

// MIDI channel (constant)
const int channel = 1;

/////////////////////////////
// PEAK CAPTURE VARIABLES ///
/////////////////////////////

// Used for various loops throughout code
int i;

// Bounds for detected peak range
int istart, iend;

// Used when parsing the detected peak range for its peak value
int ipk;

// index of the bin of max frequency.
int mindex;

// float for storing and printing max fft result
float m;

// define array to store peak information (if detecting multiple peaks)
// struct peaks {}

// bool for marking beginnings and ends of peaks
bool peakstart;

// bool for remembering if a note was buzzed
bool peakdetect;

// store length of each recorded peak
int peaklength;

// use when only want first peak
bool endcapture;


/////////////////////////////
////// TIMING VARIABLES /////
/////////////////////////////

// time measurement
unsigned long time1, time2;
int timecount = 0;
int waitcount;


/////////////////////////////
///////// CODE SETUP ////////
/////////////////////////////

void setup() {
  Serial.begin(250000);
  
  AudioMemory(60);
  
  sgtl5000.enable();
  sgtl5000.inputSelect(AUDIO_INPUT_MIC);
  // Set amplifier gain (in decibels, from 0 to 63)
  sgtl5000.micGain(40);
  // Just sets headphone jack volume
  sgtl5000.volume(0.5);
  
  // Butterworth filter, 12 dB/octave, filters out unnecessary frequencies (trumpet mouthpiece range is 87Hz -> 932 Hz)
  biquad1.setLowpass(0, 1000, 0.707);

  // begin reading audio data to detect volume (and velocity?)
  queue1.begin();
  
  // Configure the FFT window algorithm to use
  myFFT.windowFunction(AudioWindowHanning1024);

}

/////////////////////////////
///////// MAIN CODE /////////
/////////////////////////////

void loop() {
  
  ReadValves();
  
  // once new buffer fills, run it through fft
  if (myFFT.available()) {
    endcapture = false;
    peakstart = false;
    peakdetect = false;
    // Initialize to a number that is unused. In CapturePeak() no note will sound if mindex does not change, and remains 512.
    mindex = 512;
    // initialize to zero for CapturePeak()
    m = 0;

    // Higher i means higher frequencies - I believe there are 26 bins
    for (i = 0; i < 26; i++) {
      // Include fft correction factor? You should research what the magnitude here represents. What are the units?
      n = (float)myFFT.read(i); // 1.0 represents a full scale sine wave
      
      // send serial data to MATLAB
      // Serial.print(n);
      // Serial.print(" ");
      
      // Returns a number (mindex) representing fundamental frequency
      CapturePeak();
    }
    
    // for MATLAB
    // Serial.println();
    
    // time the code (11.5 ms as of 1/10)
    /*
    if (timecount%2) {
      time2 = millis();
      Serial.print(time2-time1);
      Serial.println();
    }
    time1 = millis();
    timecount = timecount + 1;
    */
    

    // Finds volume of signal
    // vol = (float)myFFT.read(mindex);
    // Prints out volume
    // Serial.println(vol);

    sendMIDIdata();
  }
}

/////////////////////////////
/////// VALVE READING ///////
/////////////////////////////
void ReadValves(){
  // Check pot inputs
  v1 = analogRead(16);
  //Serial.print(v1);
  //Serial.println(' ');
  v2 = analogRead(14);
  //Serial.print(v2);
  //Serial.print(' ');
  v3 = analogRead(17);
  //Serial.println(v3);

  // Assign valve variables booleans based on their state 
  if (v1 < 512) {
    valve1 = true;
  } else {
    valve1 = false;
  }
  if (v2 < 512) {
    valve2 = true;
  } else {
    valve2 = false;
  }
  if (v3 < 512) {
    valve3 = true;
  } else {
    valve3 = false;
  }

  // Combine all valve states into one number
  combo = (valve1 << 2) + (valve2 << 1) + valve3;
}

/////////////////////////////
///// FFT PEAK CAPTURE //////
/////////////////////////////
// find and store peak the value and index if it is loud and a lower frequency than the last recorded value.
// This ensures that the fundmental is recorded, and not a harmonic.
// Additionally, don't include very low frequencies because it is likely noise and not the intended pitch
void CapturePeak(){
    if (n > 0.07 && i > 4 && !peakstart && !endcapture) {
      peakstart = true;
      istart = i;
      peakdetect = true;
    }
    if (n < 0.07 && i > 4 && peakstart && !endcapture) {
      // uncomment if capturing more than one peak
      // peakstart = false;
      endcapture = true;
      iend = i;
      // find number of indexes in the peak
      peaklength = iend - istart;
      for (ipk = 0; ipk < peaklength; ipk++) {
        if (myFFT.read(istart + ipk) > m) {
          m = myFFT.read(ipk + istart);
          mindex = ipk + istart;
        }
      }
    }
    // Set note = 0 if no peak was detected
    if (mindex == 512) {
      note = 0;
    }
}

/////////////////////////////
////////// MIDI SEND ////////
/////////////////////////////

void sendMIDIdata(){
  
  // Determine the note velocity
  if (queue1.available() >= 8) {
    for (i = 0; i < 8; i++) {
      memcpy(audio + 128*i, queue1.readBuffer(), 256);
      queue1.freeBuffer();
    }
    tot = 0;

    for (i = 0; i < 1024; i++) {
      // int64_t type required because tot would overload with just 32 bit
      tot = ((int64_t)audio[i]*(int64_t)audio[i]) + tot;
      // Moniter the mic signal in real time
      // Serial.println(audio[i]);
    }
    rms = (int16_t)sqrt(tot/1024);
  }
  
  // conversion to MIDI velocity value
  // Full-scale sine wave has amplitude of 2^15, and the corresponding rms value is 23171.5
  // velocity = rms*127/23171;

  // Temporarily trying to find velocity with the peak FFT value instead, may be more reliable (And so it is!)
  // Change denominator to current max FFT bin amplitude
  // also acts as MIDI volume

  velocity = m*127/0.6;

  // Assign note based on mindex and valve combination
  switch (combo) {
    case 0:
        if (mindex >= 2 && mindex <= 4) {
          note = 40; // E3
        } else if (mindex >= 5 && mindex <= 6) {
          note = 47; // B3
        } else if (mindex >= 7 && mindex <= 8) {
          note = 52; // E4
        } else if (mindex >= 9 && mindex <= 10) {
          note = 56; // Ab4 (G#4)
        } else if (mindex >= 11 && mindex <= 13) {
          note = 59; // B4
        } else if (mindex >= 14 && mindex <= 20) {
          note = 64; // E5
        }
        break;
    case 2:
        if (mindex >= 2 && mindex <= 5) {
          note = 41; // F3
        } else if (mindex >= 6 && mindex <= 7) {
          note = 48; // C4
        } else if (mindex >= 8 && mindex <= 9) {
          note = 53; // F4
        } else if (mindex >= 10 && mindex <= 11) {
          note = 57; // A4
        } else if (mindex >= 12 && mindex <= 14) {
          note = 60; // C5
        } else if (mindex >= 15 && mindex <= 20) {
          note = 65; // F5
        }
        break;
    case 4:
        if (mindex >= 2 && mindex <= 5) {
          note = 42; // Gb3
        } else if (mindex >= 6 && mindex <= 7) {
          note = 49; // Db4
        } else if (mindex >= 8 && mindex <= 9) {
          note = 54; // Gb4
        } else if (mindex >= 10 && mindex <= 11) {
          note = 58; // Bb4
        } else if (mindex >= 12 && mindex <= 14) {
          note = 61; // Db5
        } else if (mindex >= 15 && mindex <= 20) {
          note = 66; // Gb5
        }
        break;
    case 6:
    case 1:
        if (mindex >= 2 && mindex <= 5) {
          note = 43; // G3
        } else if (mindex >= 6 && mindex <= 7) {
          note = 50; // D4
        } else if (mindex >= 8 && mindex <= 10) {
          note = 55; // G4
        } else if (mindex >= 11 && mindex <= 12) {
          note = 59; // B4
        } else if (mindex >= 13 && mindex <= 15) {
          note = 62; // D5
        } else if (mindex >= 16 && mindex <= 22) {
          note = 67; // G5
        }
        break;
    case 3:
        if (mindex >= 2 && mindex <= 5) {
          note = 44; // Ab3
        } else if (mindex >= 6 && mindex <= 8) {
          note = 51; // Eb4
        } else if (mindex >= 9 && mindex <= 10) {
          note = 56; // Ab4
        } else if (mindex >= 11 && mindex <= 13) {
          note = 60; // C5
        } else if (mindex >= 14 && mindex <= 16) {
          note = 63; // Eb5
        } else if (mindex >= 17 && mindex <= 22) {
          note = 68; // Ab5
        }
        break;
    case 5:
        if (mindex >= 2 && mindex <= 6) {
          note = 45; // A3
        } else if (mindex >= 7 && mindex <= 8) {
          note = 52; // E4
        } else if (mindex >= 9 && mindex <= 11) {
          note = 57; // A4
        } else if (mindex >= 12 && mindex <= 13) {
          note = 61; // Db5
        } else if (mindex >= 14 && mindex <= 17) {
          note = 64; // E5
        } else if (mindex >= 18 && mindex <= 22) {
          note = 69; // A5
        }
        break;
    case 7:
        if (mindex >= 2 && mindex <= 6) {
          note = 46; // Bb3
        } else if (mindex >= 7 && mindex <= 9) {
          note = 53; // F4
        } else if (mindex >= 10 && mindex <= 12) {
          note = 58; // Bb4
        } else if (mindex >= 13 && mindex <= 14) {
          note = 62; // D5
        } else if (mindex >= 15 && mindex <= 20) {
          note = 65; // F5
        } else if (mindex >= 21 && mindex <= 22) {
          note = 70; // Bb5
        }
        break; 
  }

  // Send volume signals whenever a peak is detected
  if (peakdetect == true) {
    usbMIDI.sendControlChange(07, velocity, channel);
    // Serial.println(velocity);
  }
  
  // Send note on/off data if the note has changed
  if (note != noteold) {
    // Only send note on message if a peak was detected and note !=0
    // TODO: note != 0 part is probably a sloppy way of fixing a bug where playing a note about a high Bb triggers a very low note on (probably note 0)
    if (peakdetect == true && note != 0) {
      usbMIDI.sendNoteOn(note, velocity, channel);
      //Serial.print("note on: ");
      //Serial.println(note);
    }
    if (noteold != 0) {
      usbMIDI.sendNoteOff(noteold, velocity, channel);
      //Serial.print("note off: ");
      //Serial.println(noteold);
    }
  }

  // store note and valve information for next loop's comparisons
  noteold = note;
}
